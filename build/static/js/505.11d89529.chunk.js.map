{"version":3,"file":"static/js/505.11d89529.chunk.js","mappings":"4IAUA,MAAMA,EAAU,eAEVC,EAAS,CACbC,SAAU,WACVC,MAAO,QACPC,WAAY,aACZC,eAAgB,iBAChBC,WAAY,aACZC,SAAU,WACVC,MAAO,QACPC,KAAM,OACNC,WAAY,aACZC,KAAM,QAIFC,EAAiBA,IACd,IAAIC,SAAQ,CAACC,EAASC,KAC3BC,QAAQC,IAAI,+CACZ,MAAMC,EAAgBC,UAAUP,eAAeZ,GAE/CkB,EAAcE,UAAY,KACxBJ,QAAQC,IAAI,0CACZH,GAAQ,EAAK,EAGfI,EAAcG,QAAWC,IACvBN,QAAQO,KAAK,kCAAmCD,GAChDR,GAAQ,EAAM,EAGhBI,EAAcM,UAAY,KACxBR,QAAQO,KAAK,wEACbT,GAAQ,EAAM,CACf,IAKCW,EAAc,IAAIC,IAKlBC,EAAiB,CAQrBC,cAAc,EAKdC,YAAY,EAMZ,gBAAMC,GAEJC,KAAKH,cAAe,EACpBG,KAAKF,YAAa,EAElB,IACEb,QAAQC,IAAI,sDAGOe,aAAaC,QAAQ,oBAGtCjB,QAAQC,IAAI,wEACNL,IACNoB,aAAaE,QAAQ,iBAAkB,SAIzCH,KAAKI,SAAWJ,KAAKK,gBACrBpB,QAAQC,IAAI,mDAjFC,GAuGb,OAnBuBc,KAAKM,0BAE1BrB,QAAQO,KAAK,6EACPQ,KAAKO,oBACXP,KAAKI,SAAWJ,KAAKK,uBAIjBL,KAAKQ,2BAGXR,KAAKF,YAAa,EAClBE,KAAKH,cAAe,EACpBZ,QAAQC,IAAI,yDAA0Dc,KAAKF,YAC3Eb,QAAQC,IAAI,yBAAuBuB,MAAMC,KAAKV,KAAKI,GAAGO,kBAAkBC,KAAK,OAG7EX,aAAaE,QAAQ,iBAAkB,QAEhCH,KAAKI,EACd,CAAE,MAAOb,GACPN,QAAQM,MAAM,sCAAuCA,GACrDS,KAAKH,cAAe,EACpBG,KAAKF,YAAa,EAElBE,KAAKa,wBACLZ,aAAaE,QAAQ,iBAAkB,SACvClB,QAAQC,IAAI,oEACd,CACF,EAOAoB,qBAAAA,GACE,IACE,IAAKN,KAAKI,GAAI,OAAO,EAErB,MAaMU,EAbiB,CACrB5C,EAAOC,SACPD,EAAOE,MACPF,EAAOG,WACPH,EAAOI,eACPJ,EAAOK,WACPL,EAAOM,SACPN,EAAOO,MACPP,EAAOQ,KACPR,EAAOS,WACPT,EAAOU,MAG4BmC,QAAOC,IACzChB,KAAKI,GAAGO,iBAAiBM,SAASD,KAGrC,QAAIF,EAAcI,OAAS,KACzBjC,QAAQO,KAAK,mBAAoBsB,EAAcF,KAAK,QAC7C,EAIX,CAAE,MAAOrB,GAEP,OADAN,QAAQM,MAAM,4BAA6BA,IACpC,CACT,CACF,EAOA,uBAAMgB,GACJ,IAgBE,OAfAtB,QAAQC,IAAI,4CAGRc,KAAKI,KACPJ,KAAKI,GAAGe,QACRnB,KAAKI,GAAK,YAINvB,IAGNoB,aAAamB,WAAW,kBAExBnC,QAAQC,IAAI,wFACL,CACT,CAAE,MAAOK,GAEP,OADAN,QAAQM,MAAM,kCAAmCA,IAC1C,CACT,CACF,EAQA,aAAMW,CAAQmB,EAAWC,GAEvB,MAAMC,EAAQ,GAAAC,OAAMH,EAAS,KAAAG,OAAIF,GACjC,GAAI5B,EAAY+B,IAAIF,GAClB,OAAO7B,EAAYgC,IAAIH,GAGzB,IAEE,GAAIvB,KAAKI,GAAI,CACX,MACMY,EADchB,KAAKI,GAAGuB,YAAYN,EAAW,YACzBO,YAAYP,GAChCQ,QAAe7B,KAAK8B,kBAAkBd,EAAMU,IAAIJ,IAOtD,YAJeS,IAAXF,GACFnC,EAAYsC,IAAIT,EAAUM,GAGrBA,CACT,CAGA,OAAI7B,KAAKiC,gBACAjC,KAAKiC,gBAAgB/B,QAAQqB,GAG/B,IACT,CAAE,MAAOhC,GAIP,OAHAN,QAAQM,MAAM,sBAADiC,OAAuBF,EAAG,cAAAE,OAAaH,EAAS,KAAK9B,GAG9DS,KAAKiC,gBACAjC,KAAKiC,gBAAgB/B,QAAQqB,GAG/B,IACT,CACF,EASA,aAAMpB,CAAQkB,EAAWC,EAAKY,GAC5B,IAKE,GAHAxC,EAAYsC,IAAI,GAADR,OAAIH,EAAS,KAAAG,OAAIF,GAAOY,IAGlClC,KAAKI,GAER,YADAH,aAAaE,QAAQ,GAADqB,OAAIH,EAAS,KAAAG,OAAIF,GAAOa,KAAKC,UAAUF,IAK7D,MAAMP,EAAc3B,KAAKI,GAAGuB,YAAYN,EAAW,aAC7CL,EAAQW,EAAYC,YAAYP,GAGhCgB,EAA+B,OAAlBrB,EAAMsB,cAGnB,IAAIxD,SAAQ,CAACC,EAASC,KAC1B,IAAIuD,EAEJ,GAAIF,EAAY,CAEd,MAAMG,EAAUxB,EAAMsB,QAEhBG,EAAgC,kBAAVP,GAAgC,OAAVA,GAAcQ,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACzDR,GAAK,IAAE,CAACM,GAAUlB,IACvB,CAAE,CAACkB,GAAUlB,EAAKqB,KAAMT,GAG1BK,EAAUvB,EAAM4B,IAAIH,EACtB,MAEEF,EAAUvB,EAAM4B,IAAIV,EAAOZ,GAG7BK,EAAYkB,WAAa,IAAM9D,IAC/B4C,EAAYrC,QAAWwD,GAAM9D,EAAO8D,EAAEC,OAAOxD,MAAM,IAIjDS,KAAKgD,iBAAiB3B,UAClBrB,KAAKiD,gBAAgB5B,EAAWC,EAAKY,EAE/C,CAAE,MAAO3C,GACPN,QAAQM,MAAM,0BAADiC,OAA2BF,EAAG,cAAAE,OAAaH,EAAS,KAAK9B,GAEtE,IACEU,aAAaE,QAAQ,GAADqB,OAAIH,EAAS,KAAAG,OAAIF,GAAOa,KAAKC,UAAUF,GAC7D,CAAE,MAAOY,GAEP,MADA7D,QAAQM,MAAM,uCAAwCuD,GAChDvD,CACR,CACF,CACF,EAQA,gBAAM6B,CAAWC,EAAWC,GAE1B,MAAMC,EAAQ,GAAAC,OAAMH,EAAS,KAAAG,OAAIF,GACjC5B,EAAYwD,OAAO3B,GAEnB,IAEE,GAAIvB,KAAKI,GAAI,CACX,MACMY,EADchB,KAAKI,GAAGuB,YAAYN,EAAW,aACzBO,YAAYP,GAQtC,aAPMrB,KAAK8B,kBAAkBd,EAAMkC,OAAO5B,SAGtCtB,KAAKgD,iBAAiB3B,UAClBrB,KAAKiD,gBAAgB5B,EAAWC,EAAK,KAAM,UAIrD,CAGA,GAAItB,KAAKiC,gBAEP,YADAjC,KAAKiC,gBAAgBb,WAAWG,EAGpC,CAAE,MAAOhC,GACPN,QAAQM,MAAM,wBAADiC,OAAyBF,EAAG,cAAAE,OAAaH,EAAS,KAAK9B,GAGhES,KAAKiC,iBACPjC,KAAKiC,gBAAgBb,WAAWG,EAEpC,CACF,EAOA,iBAAM4B,CAAY9B,GAChB,IAEE,GAAIrB,KAAKI,GAAI,CACX,MACMY,EADchB,KAAKI,GAAGuB,YAAYN,EAAW,YACzBO,YAAYP,GAEtC,aADqBrB,KAAK8B,kBAAkBd,EAAMoC,WACjC,EACnB,CAGA,OAAIpD,KAAKiC,gBACAjC,KAAKiC,gBAAgBkB,YAAY9B,GAGnC,EACT,CAAE,MAAO9B,GAIP,OAHAN,QAAQM,MAAM,yCAADiC,OAA0CH,EAAS,KAAK9B,GAGjES,KAAKiC,gBACAjC,KAAKiC,gBAAgBkB,YAAY9B,GAGnC,EACT,CACF,EAOAgC,UAAAA,CAAWhC,GACT,GAAIA,EAAW,CAEb,MAAMiC,EAAM,GAAA9B,OAAMH,EAAS,KAC3B,IAAK,MAAMC,KAAO5B,EAAY6D,OACxBjC,EAAIkC,WAAWF,IACjB5D,EAAYwD,OAAO5B,EAGzB,MAEE5B,EAAY+D,OAEhB,EAOA,gBAAMC,CAAWrC,GAEfrB,KAAKqD,WAAWhC,GAEhB,IAEE,GAAIrB,KAAKI,GAAI,CACX,MACMY,EADchB,KAAKI,GAAGuB,YAAYN,EAAW,aACzBO,YAAYP,GAQtC,aAPMrB,KAAK8B,kBAAkBd,EAAMyC,cAG/BzD,KAAKgD,iBAAiB3B,UAClBrB,KAAKiD,gBAAgB5B,EAAW,KAAM,KAAM,SAItD,CAGA,GAAIrB,KAAKiC,gBAEP,YADAjC,KAAKiC,gBAAgByB,WAAWrC,EAGpC,CAAE,MAAO9B,GACPN,QAAQM,MAAM,wBAADiC,OAAyBH,EAAS,KAAK9B,GAGhDS,KAAKiC,iBACPjC,KAAKiC,gBAAgByB,WAAWrC,EAEpC,CACF,EAWA,qBAAM4B,CAAgB5B,EAAWC,EAAKY,GAA8B,IAAvByB,EAASC,UAAA1C,OAAA,QAAAa,IAAA6B,UAAA,GAAAA,UAAA,GAAG,SACvD,IACE,MAAMC,EAAW,CACfC,GAAG,GAADtC,OAAKH,EAAS,KAAAG,OAAIF,EAAG,KAAAE,OAAIuC,KAAKC,OAChChD,MAAOK,EACPC,MACAY,QACAyB,YACAM,WAAW,IAAIF,MAAOG,cACtBC,SAAU,EACVC,QAAQ,GAIJpD,EADchB,KAAKI,GAAGuB,YAAYzD,EAAOK,WAAY,aACjCqD,YAAY1D,EAAOK,kBACvCyB,KAAK8B,kBAAkBd,EAAMqD,IAAIR,GACzC,CAAE,MAAOtE,GACPN,QAAQM,MAAM,sDAA8CA,EAC9D,CACF,EAOA,kBAAM+E,GAA2B,IAAdC,EAAKX,UAAA1C,OAAA,QAAAa,IAAA6B,UAAA,GAAAA,UAAA,GAAG,IACzB,IACE,IAAK5D,KAAKI,GAAI,MAAO,GAErB,MACMY,EADchB,KAAKI,GAAGuB,YAAYzD,EAAOK,WAAY,YACjCqD,YAAY1D,EAAOK,YAEvCgE,EADQvB,EAAMwD,MAAM,UACJpB,OAAO,EAAGmB,GAEhC,aAAavE,KAAK8B,kBAAkBS,EACtC,CAAE,MAAOhD,GAEP,OADAN,QAAQM,MAAM,6CAAwCA,GAC/C,EACT,CACF,EAOA,kBAAMkF,CAAaC,GACjB,GAAKjE,MAAMkE,QAAQD,IAAuB,IAAfA,EAAIxD,OAE/B,IACE,MACMF,EADchB,KAAKI,GAAGuB,YAAYzD,EAAOK,WAAY,aACjCqD,YAAY1D,EAAOK,YAEvCqG,EAAWF,EAAIG,KAAIC,UACvB,MAAMC,QAAa/E,KAAK8B,kBAAkBd,EAAMU,IAAIoC,IACpD,GAAIiB,EAGF,OAFAA,EAAKX,QAAS,EACdW,EAAKC,UAAW,IAAIjB,MAAOG,cACpBlE,KAAK8B,kBAAkBd,EAAM4B,IAAImC,GAC1C,UAGIjG,QAAQmG,IAAIL,EACpB,CAAE,MAAOrF,GACPN,QAAQM,MAAM,2CAA4CA,EAC5D,CACF,EAQAyD,iBAAiB3B,GAEQ,CACrBnD,EAAOE,MACPF,EAAOG,WACPH,EAAOM,SACPN,EAAOO,OAGayG,SAAS7D,GAQjC,8BAAMb,GACJ,IAEE,MAAM2E,QAAiBnF,KAAKE,QAAQhC,EAAOC,SAAU,gBACjDgH,GACFzF,EAAYsC,IAAI,GAADR,OAAItD,EAAOC,SAAQ,iBAAiBgH,GAIrD,MAAMC,QAAuBpF,KAAKqF,qBAClC,GAAID,GAAkBA,EAAelE,OAAS,EAC5C,IAAK,MAAMoE,KAAWF,EACpB1F,EAAYsC,IAAI,GAADR,OAAItD,EAAOM,SAAQ,KAAAgD,OAAI8D,EAAQxB,IAAMwB,GAKxD,MAAMC,QAAoBvF,KAAKwF,kBAC/B,GAAID,GAAeA,EAAYrE,OAAS,EACtC,IAAK,MAAMuE,KAAQF,EACjB7F,EAAYsC,IAAI,GAADR,OAAItD,EAAOO,MAAK,KAAA+C,OAAIiE,EAAK3B,IAAM2B,EAGpD,CAAE,MAAOlG,GACPN,QAAQM,MAAM,mDAAiDA,EACjE,CACF,EAOA,wBAAM8F,GACJ,IACE,IAAKrF,KAAKI,GAAI,MAAO,GAErB,MACMY,EADchB,KAAKI,GAAGuB,YAAYzD,EAAOM,SAAU,YAC/BoD,YAAY1D,EAAOM,UAEvC+D,EADQvB,EAAMwD,MAAM,UACJpB,OAAO,UAE7B,aAAapD,KAAK8B,kBAAkBS,EACtC,CAAE,MAAOhD,GAEP,OADAN,QAAQM,MAAM,+BAAgCA,GACvC,EACT,CACF,EAOA,qBAAMiG,GACJ,IACE,IAAKxF,KAAKI,GAAI,MAAO,GAErB,MACMY,EADchB,KAAKI,GAAGuB,YAAYzD,EAAOO,MAAO,YAC5BmD,YAAY1D,EAAOO,OAEvC8D,EADQvB,EAAMwD,MAAM,UACJpB,OAAO,UAE7B,aAAapD,KAAK8B,kBAAkBS,EACtC,CAAE,MAAOhD,GAEP,OADAN,QAAQM,MAAM,+BAAgCA,GACvC,EACT,CACF,EAOAuF,cAAmBzE,SACV,IAAIvB,SAAQ,CAACC,EAASC,KAC3B,IAAK0G,OAAOtG,UAEV,YADAJ,EAAO,IAAI2G,MAAM,+CAInB,MAAMpD,EAAUnD,UAAUwG,KAAK3H,EAhmBlB,GAkmBbsE,EAAQjD,QAAWuG,IACjB5G,QAAQM,MAAM,2BAA4BsG,EAAM9C,OAAOxD,OACvDP,EAAO,IAAI2G,MAAM,4BAA8BE,EAAM9C,OAAOxD,OAAO,EAGrEgD,EAAQlD,UAAawG,IACnB,MAAMzF,EAAKyF,EAAM9C,OAAOlB,OACxB5C,QAAQC,IAAI,2CAAyCkB,EAAG0F,SACxD7G,QAAQC,IAAI,yBAAuBuB,MAAMC,KAAKN,EAAGO,kBAAkBC,KAAK,OACxE7B,EAAQqB,EAAG,EAGbmC,EAAQwD,gBAAmBF,IACzB5G,QAAQC,IAAI,yDA/mBD,GAgnBX,MAAMkB,EAAKyF,EAAM9C,OAAOlB,OAGlBmE,EAAc,SAAC3E,GAA6C,IAAlCiB,EAAOsB,UAAA1C,OAAA,QAAAa,IAAA6B,UAAA,GAAAA,UAAA,GAAG,KAAMqC,EAAOrC,UAAA1C,OAAA,QAAAa,IAAA6B,UAAA,GAAAA,UAAA,GAAG,GACxD,IACE,GAAIxD,EAAGO,iBAAiBM,SAASI,GAE/B,OADApC,QAAQC,IAAI,SAADsC,OAAUH,EAAS,0CACvBjB,EAAGuB,YAAYN,GAAWO,YAAYP,GAG/CpC,QAAQC,IAAI,iBAADsC,OAAkBH,EAAS,QACtC,MAAML,EAAQsB,EACVlC,EAAG8F,kBAAkB7E,EAAW,CAAEiB,YAClClC,EAAG8F,kBAAkB7E,GAOzB,OAJA4E,EAAQE,SAAQC,IAA8B,IAA7B,KAAEC,EAAI,KAAEC,EAAI,QAAEC,GAASH,EACtCpF,EAAMwF,YAAYH,EAAMC,EAAMC,GAAW,CAAEE,QAAQ,GAAQ,IAGtDzF,CACT,CAAE,MAAOzB,GAEP,MADAN,QAAQM,MAAM,uBAADiC,OAAwBH,EAAS,KAAK9B,GAC7CA,CACR,CACF,EAGAyG,EAAY9H,EAAOC,UAGnB6H,EAAY9H,EAAOE,MAAO,KAAM,CAC9B,CAAEiI,KAAM,YAAaC,KAAM,aAC3B,CAAED,KAAM,cAAeC,KAAM,eAC7B,CAAED,KAAM,SAAUC,KAAM,YAI1BN,EAAY9H,EAAOG,WAAY,cAAe,CAC5C,CAAEgI,KAAM,WAAYC,KAAM,YAC1B,CAAED,KAAM,QAASC,KAAM,WAIzBN,EAAY9H,EAAOI,eAAgB,YAAa,CAC9C,CAAE+H,KAAM,YAAaC,KAAM,aAC3B,CAAED,KAAM,YAAaC,KAAM,eAI7BN,EAAY9H,EAAOK,WAAY,KAAM,CACnC,CAAE8H,KAAM,SAAUC,KAAM,UACxB,CAAED,KAAM,YAAaC,KAAM,aAC3B,CAAED,KAAM,QAASC,KAAM,WAIzBN,EAAY9H,EAAOM,SAAU,KAAM,CACjC,CAAE6H,KAAM,SAAUC,KAAM,UACxB,CAAED,KAAM,OAAQC,KAAM,UAIxBN,EAAY9H,EAAOO,MAAO,KAAM,CAC9B,CAAE4H,KAAM,SAAUC,KAAM,UACxB,CAAED,KAAM,OAAQC,KAAM,UAIxBN,EAAY9H,EAAOQ,KAAM,MAGzBsH,EAAY9H,EAAOS,WAAY,MAG/BqH,EAAY9H,EAAOU,KAAM,MAEzBK,QAAQC,IAAI,iEAAwD,CACrE,IAUL4C,kBAAkBS,GACT,IAAIzD,SAAQ,CAACC,EAASC,KAC3BuD,EAAQlD,UAAawG,GAAU9G,EAAQ8G,EAAM9C,OAAOlB,QACpDU,EAAQjD,QAAWuG,GAAU7G,EAAO6G,EAAM9C,OAAOxD,MAAM,IAQ3DsB,qBAAAA,GACE5B,QAAQO,KAAK,qCAGbQ,KAAKiC,gBAAkB,CACrB/B,OAAAA,CAAQoB,GACN,IACE,MAAMY,EAAQjC,aAAaC,QAAQoB,GACnC,OAAOY,EAAQC,KAAKuE,MAAMxE,GAAS,IACrC,CAAE,MAAOY,GAEP,OADA7D,QAAQM,MAAM,+BAAgCuD,GACvC,IACT,CACF,EAEA3C,OAAAA,CAAQmB,EAAKY,GACX,IACEjC,aAAaE,QAAQmB,EAAKa,KAAKC,UAAUF,GAC3C,CAAE,MAAOY,GACP7D,QAAQM,MAAM,oCAAqCuD,EACrD,CACF,EAEA1B,UAAAA,CAAWE,GACT,IACErB,aAAamB,WAAWE,EAC1B,CAAE,MAAOwB,GACP7D,QAAQM,MAAM,mCAAoCuD,EACpD,CACF,EAEAK,WAAAA,CAAY9B,GACV,IACE,MAAMsF,EAAQ,GACRrD,EAAM,GAAA9B,OAAMH,EAAS,KAE3B,IAAK,IAAIuF,EAAI,EAAGA,EAAI3G,aAAaiB,OAAQ0F,IAAK,CAC5C,MAAMtF,EAAMrB,aAAaqB,IAAIsF,GACzBtF,EAAIkC,WAAWF,IACjBqD,EAAME,KAAK7G,KAAKE,QAAQoB,GAE5B,CAEA,OAAOqF,CACT,CAAE,MAAO7D,GAEP,OADA7D,QAAQM,MAAM,8CAA+CuD,GACtD,EACT,CACF,EAEAY,UAAAA,CAAWrC,GACT,IACE,MAAMiC,EAAM,GAAA9B,OAAMH,EAAS,KACrByF,EAAe,GAErB,IAAK,IAAIF,EAAI,EAAGA,EAAI3G,aAAaiB,OAAQ0F,IAAK,CAC5C,MAAMtF,EAAMrB,aAAaqB,IAAIsF,GACzBtF,EAAIkC,WAAWF,IACjBwD,EAAaD,KAAKvF,EAEtB,CAEAwF,EAAaX,SAAQ7E,GAAOrB,aAAamB,WAAWE,IACtD,CAAE,MAAOwB,GACP7D,QAAQM,MAAM,wCAAyCuD,EACzD,CACF,EAEJ,GAIF,IAGAlD,EAAemH,cAAgBjC,eAAexD,GAC5C,IAEE,IAAID,EAAYnD,EAAOC,SACnB6I,EAAW1F,EAEf,GAAIA,EAAI4D,SAAS,KAAM,CACrB,MAAM+B,EAAQ3F,EAAI4F,MAAM,KACxB7F,EAAY4F,EAAM,GAClBD,EAAWC,EAAME,MAAM,GAAGvG,KAAK,IACjC,CAGA,aAAaZ,KAAKE,QAAQmB,EAAW2F,EACvC,CAAE,MAAOzH,GAEP,OADAN,QAAQM,MAAM,sBAADiC,OAAuBF,EAAG,iBAAiB/B,GACjD,IACT,CACF,EAGAK,EAAewH,iBAAmBxH,EAAeM,QAGjDN,EAAeM,QAAU,SAASmH,EAAgB/F,GAEhD,YAAYS,IAART,EACKtB,KAAK+G,cAAcM,GAGrBrH,KAAKoH,iBAAiBC,EAAgB/F,EAC/C,EAEA1B,EAAe0H,cAAgBxC,eAAexD,EAAKY,GACjD,IAEE,IAAIb,EAAYnD,EAAOC,SACnB6I,EAAW1F,EAEf,GAAIA,EAAI4D,SAAS,KAAM,CACrB,MAAM+B,EAAQ3F,EAAI4F,MAAM,KACxB7F,EAAY4F,EAAM,GAClBD,EAAWC,EAAME,MAAM,GAAGvG,KAAK,IACjC,CAIA,aADMZ,KAAKG,QAAQkB,EAAW2F,EAAU9E,IACjC,CACT,CAAE,MAAO3C,GAGP,OAFAN,QAAQM,MAAM,0BAADiC,OAA2BF,EAAG,iBAAiB/B,KAExDS,KAAKiC,kBACPjC,KAAKiC,gBAAgB9B,QAAQmB,EAAKY,IAC3B,EAGX,CACF,EAGAtC,EAAe2H,iBAAmB3H,EAAeO,QAGjDP,EAAeO,QAAU,SAASkH,EAAgBG,EAAYtF,GAE5D,YAAcH,IAAVG,EACKlC,KAAKsH,cAAcD,EAAgBG,GAGrCxH,KAAKuH,iBAAiBF,EAAgBG,EAAYtF,EAC3D,EAGAtC,EAAe6H,iBAAmB3C,eAAexD,GAC/C,IACE,IAAID,EAAYnD,EAAOC,SACnB6I,EAAW1F,EAEf,GAAIA,EAAI4D,SAAS,KAAM,CACrB,MAAM+B,EAAQ3F,EAAI4F,MAAM,KACxB7F,EAAY4F,EAAM,GAClBD,EAAWC,EAAME,MAAM,GAAGvG,KAAK,IACjC,CAGA,MACMI,EADchB,KAAKI,GAAGuB,YAAYN,EAAW,aACzBO,YAAYP,SAChCrB,KAAK8B,kBAAkBd,EAAMkC,OAAO8D,IAG1C,MAAMzF,EAAQ,GAAAC,OAAMH,EAAS,KAAAG,OAAIwF,GAGjC,OAFAtH,EAAYwD,OAAO3B,IAEZ,CACT,CAAE,MAAOhC,GAGP,OAFAN,QAAQM,MAAM,wBAADiC,OAAyBF,EAAG,iBAAiB/B,KAEtDS,KAAKiC,kBACPjC,KAAKiC,gBAAgBb,WAAWE,IACzB,EAGX,CACF,EAGA1B,EAAe8H,oBAAsB9H,EAAewB,WAGpDxB,EAAewB,WAAa,SAASiG,EAAgB/F,GAEnD,YAAYS,IAART,EACKtB,KAAKyH,iBAAiBJ,GAGxBrH,KAAK0H,oBAAoBL,EAAgB/F,EAClD,C","sources":["services/sync/offlineStorage.js"],"sourcesContent":["/**\n * Sistema de Armazenamento Offline Avançado para o Quero Paz\n * \n * Este módulo implementa um sistema de armazenamento baseado em IndexedDB\n * com suporte a sincronização eficiente, compressão e fallback.\n * \n * Atualizado para garantir compatibilidade com outros módulos e eliminar erros de recursividade.\n */\n\n// Configuração do banco de dados\nconst DB_NAME = 'quero_paz_db';\nconst DB_VERSION = 6; // Versão aumentada significativamente para forçar atualização\nconst STORES = {\n  SETTINGS: 'settings',\n  CALLS: 'calls',\n  REPUTATION: 'reputation',\n  COMMUNITY_DATA: 'community_data',\n  SYNC_QUEUE: 'sync_queue',\n  PROFILES: 'profiles',\n  RULES: 'rules',\n  TEST: 'test', // Adicionado para testes\n  STATISTICS: 'statistics', // Adicionado para estatísticas\n  SYNC: 'sync' // Adicionado para dados de sincronização\n};\n\n// Função para excluir completamente o banco de dados\nconst deleteDatabase = () => {\n  return new Promise((resolve, reject) => {\n    console.log('Tentando excluir o banco de dados antigo...');\n    const deleteRequest = indexedDB.deleteDatabase(DB_NAME);\n    \n    deleteRequest.onsuccess = () => {\n      console.log('Banco de dados excluído com sucesso');\n      resolve(true);\n    };\n    \n    deleteRequest.onerror = (error) => {\n      console.warn('Erro ao excluir banco de dados:', error);\n      resolve(false); // Resolve mesmo com erro para continuar o fluxo\n    };\n    \n    deleteRequest.onblocked = () => {\n      console.warn('Exclusão do banco de dados bloqueada. Feche todas as outras abas.');\n      resolve(false);\n    };\n  });\n};\n\n// Cache para acesso rápido\nconst memoryCache = new Map();\n\n/**\n * Serviço de armazenamento offline\n */\nconst offlineStorage = {\n  /**\n   * Inicializa o sistema de armazenamento com recuperação robusta\n   * @returns {Promise<IDBDatabase>} Instância do banco de dados\n   */\n  /**\n   * Flag indicando se o armazenamento está inicializado\n   */\n  _initialized: false,\n  \n  /**\n   * Flag indicando se o banco de dados está pronto\n   */\n  _isDBReady: false,\n  \n  /**\n   * Inicializa o sistema de armazenamento com recuperação robusta\n   * @returns {Promise<IDBDatabase>} Instância do banco de dados\n   */\n  async initialize() {\n    // Resetar estado para inicialização\n    this._initialized = false;\n    this._isDBReady = false;\n    \n    try {\n      console.log('Iniciando inicialização do OfflineStorage...');\n      \n      // Primeiro, tenta excluir o banco de dados antigo para evitar problemas com stores faltantes\n      const forceReset = localStorage.getItem('force_db_reset');\n      \n      if (!forceReset) {\n        console.log('Iniciando exclusão do banco de dados para nova versão...');\n        await deleteDatabase();\n        localStorage.setItem('force_db_reset', 'true');\n      }\n      \n      // Agora abre o banco de dados com a nova versão\n      this.db = await this._openDatabase();\n      console.log('IndexedDB inicializado com sucesso com versão', DB_VERSION);\n      \n      // Verifica se todos os stores necessários existem\n      const allStoresExist = this._verifyAllStoresExist();\n      if (!allStoresExist) {\n        console.warn('Alguns stores não foram encontrados. Recriando banco de dados...');\n        await this._recreateDatabase();\n        this.db = await this._openDatabase();\n      }\n      \n      // Carrega dados críticos no cache\n      await this._loadCriticalDataToCache();\n      \n      // Tudo pronto\n      this._isDBReady = true;\n      this._initialized = true;\n      console.log('OfflineStorage inicializado com sucesso. Banco pronto:', this._isDBReady);\n      console.log('Stores disponíveis:', Array.from(this.db.objectStoreNames).join(', '));\n      \n      // Marque no localStorage que o DB foi inicializado corretamente\n      localStorage.setItem('db_initialized', 'true');\n      \n      return this.db;\n    } catch (error) {\n      console.error('Erro ao inicializar OfflineStorage:', error);\n      this._initialized = false;\n      this._isDBReady = false;\n      // Configura armazenamento de fallback\n      this._setupFallbackStorage();\n      localStorage.setItem('db_initialized', 'false');\n      console.log('Configurado armazenamento de fallback devido a falha no IndexedDB');\n    }\n  },\n  \n  /**\n   * Verifica se todos os stores necessários existem no banco\n   * @returns {boolean}\n   * @private\n   */\n  _verifyAllStoresExist() {\n    try {\n      if (!this.db) return false;\n      \n      const requiredStores = [\n        STORES.SETTINGS,\n        STORES.CALLS,\n        STORES.REPUTATION,\n        STORES.COMMUNITY_DATA,\n        STORES.SYNC_QUEUE,\n        STORES.PROFILES,\n        STORES.RULES,\n        STORES.TEST,\n        STORES.STATISTICS,\n        STORES.SYNC\n      ];\n      \n      const missingStores = requiredStores.filter(store => \n        !this.db.objectStoreNames.contains(store)\n      );\n      \n      if (missingStores.length > 0) {\n        console.warn('Stores faltando:', missingStores.join(', '));\n        return false;\n      }\n      \n      return true;\n    } catch (error) {\n      console.error('Erro ao verificar stores:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Força a recriação do banco de dados por completo\n   * @returns {Promise<boolean>}\n   * @private\n   */\n  async _recreateDatabase() {\n    try {\n      console.log('Recriando banco de dados por completo...');\n      \n      // Fecha conexão para evitar bloqueio\n      if (this.db) {\n        this.db.close();\n        this.db = null;\n      }\n      \n      // Exclui o banco\n      await deleteDatabase();\n      \n      // Limpa a flag\n      localStorage.removeItem('force_db_reset');\n      \n      console.log('Banco de dados foi excluído e será recriado na próxima inicialização');\n      return true;\n    } catch (error) {\n      console.error('Erro ao recriar banco de dados:', error);\n      return false;\n    }\n  },\n  \n  /**\n   * Obtém um item do armazenamento\n   * @param {string} storeName - Nome do store\n   * @param {string|number} key - Chave do item\n   * @returns {Promise<any>} Valor armazenado\n   */\n  async getItem(storeName, key) {\n    // Verifica se está no cache\n    const cacheKey = `${storeName}:${key}`;\n    if (memoryCache.has(cacheKey)) {\n      return memoryCache.get(cacheKey);\n    }\n    \n    try {\n      // Primeiro tenta IndexedDB\n      if (this.db) {\n        const transaction = this.db.transaction(storeName, 'readonly');\n        const store = transaction.objectStore(storeName);\n        const result = await this._promisifyRequest(store.get(key));\n        \n        // Adiciona ao cache para acesso rápido futuro\n        if (result !== undefined) {\n          memoryCache.set(cacheKey, result);\n        }\n        \n        return result;\n      }\n      \n      // Fallback para localStorage\n      if (this.fallbackStorage) {\n        return this.fallbackStorage.getItem(cacheKey);\n      }\n      \n      return null;\n    } catch (error) {\n      console.error(`Erro ao obter item ${key} do store ${storeName}:`, error);\n      \n      // Tenta fallback\n      if (this.fallbackStorage) {\n        return this.fallbackStorage.getItem(cacheKey);\n      }\n      \n      return null;\n    }\n  },\n  \n  /**\n   * Armazena um item\n   * @param {string} storeName - Nome do store\n   * @param {string|number} key - Chave do item\n   * @param {any} value - Valor a armazenar\n   * @returns {Promise<void>}\n   */\n  async setItem(storeName, key, value) {\n    try {\n      // Adiciona ao cache\n      memoryCache.set(`${storeName}:${key}`, value);\n      \n      // Se o banco não estiver disponível, usa fallback\n      if (!this.db) {\n        localStorage.setItem(`${storeName}:${key}`, JSON.stringify(value));\n        return;\n      }\n      \n      // Armazena no IndexedDB\n      const transaction = this.db.transaction(storeName, 'readwrite');\n      const store = transaction.objectStore(storeName);\n      \n      // Verificar se o store usa keyPath\n      const hasKeyPath = store.keyPath !== null;\n      \n      // Utilizamos Promise para lidar com eventos de transação\n      await new Promise((resolve, reject) => {\n        let request;\n        \n        if (hasKeyPath) {\n          // Se o store tem keyPath, precisamos incluir a chave no objeto\n          const keyName = store.keyPath;\n          // Clonar o valor para não modificar o original se for um objeto\n          const valueWithKey = typeof value === 'object' && value !== null ? \n            { ...value, [keyName]: key } : \n            { [keyName]: key, data: value };\n          \n          // Usar put sem o segundo parâmetro de chave\n          request = store.put(valueWithKey);\n        } else {\n          // Store sem keyPath - usar o método normal com chave externa\n          request = store.put(value, key);\n        }\n        \n        transaction.oncomplete = () => resolve();\n        transaction.onerror = (e) => reject(e.target.error);\n      });\n      \n      // Se for um store sincronizável, adiciona à fila de sincronização\n      if (this._isSyncableStore(storeName)) {\n        await this._addToSyncQueue(storeName, key, value);\n      }\n    } catch (error) {\n      console.error(`Erro ao armazenar item ${key} no store ${storeName}:`, error);\n      // Tenta o fallback para localStorage como último recurso\n      try {\n        localStorage.setItem(`${storeName}:${key}`, JSON.stringify(value));\n      } catch (e) {\n        console.error('Falha no fallback para localStorage:', e);\n        throw error;\n      }\n    }\n  },\n  \n  /**\n   * Remove um item do armazenamento\n   * @param {string} storeName - Nome do store\n   * @param {string|number} key - Chave do item\n   * @returns {Promise<void>}\n   */\n  async removeItem(storeName, key) {\n    // Remove do cache\n    const cacheKey = `${storeName}:${key}`;\n    memoryCache.delete(cacheKey);\n    \n    try {\n      // Primeiro tenta IndexedDB\n      if (this.db) {\n        const transaction = this.db.transaction(storeName, 'readwrite');\n        const store = transaction.objectStore(storeName);\n        await this._promisifyRequest(store.delete(key));\n        \n        // Adiciona operação de exclusão à fila de sincronização\n        if (this._isSyncableStore(storeName)) {\n          await this._addToSyncQueue(storeName, key, null, 'delete');\n        }\n        \n        return;\n      }\n      \n      // Fallback para localStorage\n      if (this.fallbackStorage) {\n        this.fallbackStorage.removeItem(cacheKey);\n        return;\n      }\n    } catch (error) {\n      console.error(`Erro ao remover item ${key} do store ${storeName}:`, error);\n      \n      // Tenta fallback\n      if (this.fallbackStorage) {\n        this.fallbackStorage.removeItem(cacheKey);\n      }\n    }\n  },\n  \n  /**\n   * Obtém todos os itens de um store\n   * @param {string} storeName - Nome do store\n   * @returns {Promise<Array>} Array de itens\n   */\n  async getAllItems(storeName) {\n    try {\n      // Primeiro tenta IndexedDB\n      if (this.db) {\n        const transaction = this.db.transaction(storeName, 'readonly');\n        const store = transaction.objectStore(storeName);\n        const result = await this._promisifyRequest(store.getAll());\n        return result || [];\n      }\n      \n      // Fallback para localStorage\n      if (this.fallbackStorage) {\n        return this.fallbackStorage.getAllItems(storeName);\n      }\n      \n      return [];\n    } catch (error) {\n      console.error(`Erro ao obter todos os itens do store ${storeName}:`, error);\n      \n      // Tenta fallback\n      if (this.fallbackStorage) {\n        return this.fallbackStorage.getAllItems(storeName);\n      }\n      \n      return [];\n    }\n  },\n  \n  /**\n   * Limpa o cache em memória\n   * @param {string} [storeName] - Nome do store (opcional, limpa todos se não especificado)\n   * @returns {void}\n   */\n  clearCache(storeName) {\n    if (storeName) {\n      // Limpa apenas o cache do store especificado\n      const prefix = `${storeName}:`;\n      for (const key of memoryCache.keys()) {\n        if (key.startsWith(prefix)) {\n          memoryCache.delete(key);\n        }\n      }\n    } else {\n      // Limpa todo o cache\n      memoryCache.clear();\n    }\n  },\n  \n  /**\n   * Limpa um store inteiro\n   * @param {string} storeName - Nome do store\n   * @returns {Promise<void>}\n   */\n  async clearStore(storeName) {\n    // Limpa o cache\n    this.clearCache(storeName);\n    \n    try {\n      // Primeiro tenta IndexedDB\n      if (this.db) {\n        const transaction = this.db.transaction(storeName, 'readwrite');\n        const store = transaction.objectStore(storeName);\n        await this._promisifyRequest(store.clear());\n        \n        // Adiciona operação de limpeza à fila de sincronização\n        if (this._isSyncableStore(storeName)) {\n          await this._addToSyncQueue(storeName, null, null, 'clear');\n        }\n        \n        return;\n      }\n      \n      // Fallback para localStorage\n      if (this.fallbackStorage) {\n        this.fallbackStorage.clearStore(storeName);\n        return;\n      }\n    } catch (error) {\n      console.error(`Erro ao limpar store ${storeName}:`, error);\n      \n      // Tenta fallback\n      if (this.fallbackStorage) {\n        this.fallbackStorage.clearStore(storeName);\n      }\n    }\n  },\n  \n  /**\n   * Adiciona à fila de sincronização\n   * @param {string} storeName - Nome do store\n   * @param {string|number} key - Chave do item\n   * @param {any} value - Valor a sincronizar\n   * @param {string} [operation='update'] - Tipo de operação\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _addToSyncQueue(storeName, key, value, operation = 'update') {\n    try {\n      const syncItem = {\n        id: `${storeName}:${key}:${Date.now()}`,\n        store: storeName,\n        key,\n        value,\n        operation,\n        timestamp: new Date().toISOString(),\n        attempts: 0,\n        synced: false\n      };\n      \n      const transaction = this.db.transaction(STORES.SYNC_QUEUE, 'readwrite');\n      const store = transaction.objectStore(STORES.SYNC_QUEUE);\n      await this._promisifyRequest(store.add(syncItem));\n    } catch (error) {\n      console.error('Erro ao adicionar à fila de sincronização:', error);\n    }\n  },\n  \n  /**\n   * Obtém fila de sincronização pendente\n   * @param {number} [limit=100] - Limite de itens\n   * @returns {Promise<Array>} Itens não sincronizados\n   */\n  async getSyncQueue(limit = 100) {\n    try {\n      if (!this.db) return [];\n      \n      const transaction = this.db.transaction(STORES.SYNC_QUEUE, 'readonly');\n      const store = transaction.objectStore(STORES.SYNC_QUEUE);\n      const index = store.index('synced');\n      const request = index.getAll(0, limit); // 0 = false (não sincronizado)\n      \n      return await this._promisifyRequest(request);\n    } catch (error) {\n      console.error('Erro ao obter fila de sincronização:', error);\n      return [];\n    }\n  },\n  \n  /**\n   * Marca itens como sincronizados\n   * @param {Array<string>} ids - IDs dos itens sincronizados\n   * @returns {Promise<void>}\n   */\n  async markAsSynced(ids) {\n    if (!Array.isArray(ids) || ids.length === 0) return;\n    \n    try {\n      const transaction = this.db.transaction(STORES.SYNC_QUEUE, 'readwrite');\n      const store = transaction.objectStore(STORES.SYNC_QUEUE);\n      \n      const promises = ids.map(async (id) => {\n        const item = await this._promisifyRequest(store.get(id));\n        if (item) {\n          item.synced = true;\n          item.syncedAt = new Date().toISOString();\n          return this._promisifyRequest(store.put(item));\n        }\n      });\n      \n      await Promise.all(promises);\n    } catch (error) {\n      console.error('Erro ao marcar itens como sincronizados:', error);\n    }\n  },\n  \n  /**\n   * Verifica se um store deve ser sincronizado\n   * @param {string} storeName - Nome do store\n   * @returns {boolean} Se o store deve ser sincronizado\n   * @private\n   */\n  _isSyncableStore(storeName) {\n    // Lista de stores que devem ser sincronizados com o servidor\n    const syncableStores = [\n      STORES.CALLS,\n      STORES.REPUTATION,\n      STORES.PROFILES,\n      STORES.RULES\n    ];\n    \n    return syncableStores.includes(storeName);\n  },\n  \n  /**\n   * Pré-carrega dados críticos no cache\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _loadCriticalDataToCache() {\n    try {\n      // Carrega configurações\n      const settings = await this.getItem(STORES.SETTINGS, 'app_settings');\n      if (settings) {\n        memoryCache.set(`${STORES.SETTINGS}:app_settings`, settings);\n      }\n      \n      // Carrega perfis ativos\n      const activeProfiles = await this._getActiveProfiles();\n      if (activeProfiles && activeProfiles.length > 0) {\n        for (const profile of activeProfiles) {\n          memoryCache.set(`${STORES.PROFILES}:${profile.id}`, profile);\n        }\n      }\n      \n      // Carrega regras ativas\n      const activeRules = await this._getActiveRules();\n      if (activeRules && activeRules.length > 0) {\n        for (const rule of activeRules) {\n          memoryCache.set(`${STORES.RULES}:${rule.id}`, rule);\n        }\n      }\n    } catch (error) {\n      console.error('Erro ao carregar dados críticos para o cache:', error);\n    }\n  },\n  \n  /**\n   * Obtém perfis ativos\n   * @returns {Promise<Array>} Perfis ativos\n   * @private\n   */\n  async _getActiveProfiles() {\n    try {\n      if (!this.db) return [];\n      \n      const transaction = this.db.transaction(STORES.PROFILES, 'readonly');\n      const store = transaction.objectStore(STORES.PROFILES);\n      const index = store.index('status');\n      const request = index.getAll('active');\n      \n      return await this._promisifyRequest(request);\n    } catch (error) {\n      console.error('Erro ao obter perfis ativos:', error);\n      return [];\n    }\n  },\n  \n  /**\n   * Obtém regras ativas\n   * @returns {Promise<Array>} Regras ativas\n   * @private\n   */\n  async _getActiveRules() {\n    try {\n      if (!this.db) return [];\n      \n      const transaction = this.db.transaction(STORES.RULES, 'readonly');\n      const store = transaction.objectStore(STORES.RULES);\n      const index = store.index('status');\n      const request = index.getAll('active');\n      \n      return await this._promisifyRequest(request);\n    } catch (error) {\n      console.error('Erro ao obter regras ativas:', error);\n      return [];\n    }\n  },\n  \n  /**\n   * Abre o banco de dados IndexedDB\n   * @returns {Promise<IDBDatabase>} Instância do banco de dados\n   * @private\n   */\n  async _openDatabase() {\n    return new Promise((resolve, reject) => {\n      if (!window.indexedDB) {\n        reject(new Error('IndexedDB não suportado neste navegador'));\n        return;\n      }\n      \n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n      \n      request.onerror = (event) => {\n        console.error('Erro ao abrir IndexedDB:', event.target.error);\n        reject(new Error('Erro ao abrir IndexedDB: ' + event.target.error));\n      };\n      \n      request.onsuccess = (event) => {\n        const db = event.target.result;\n        console.log('IndexedDB aberto com sucesso. Versão:', db.version);\n        console.log('Stores disponíveis:', Array.from(db.objectStoreNames).join(', '));\n        resolve(db);\n      };\n      \n      request.onupgradeneeded = (event) => {\n        console.log('Atualizando estrutura do banco de dados para versão', DB_VERSION);\n        const db = event.target.result;\n        \n        // Cria todos os stores necessários\n        const createStore = (storeName, keyPath = null, indexes = []) => {\n          try {\n            if (db.objectStoreNames.contains(storeName)) {\n              console.log(`Store ${storeName} já existe. Pulando criação.`);\n              return db.transaction(storeName).objectStore(storeName);\n            }\n            \n            console.log(`Criando store ${storeName}...`);\n            const store = keyPath \n              ? db.createObjectStore(storeName, { keyPath }) \n              : db.createObjectStore(storeName);\n            \n            // Cria índices\n            indexes.forEach(({ name, path, options }) => {\n              store.createIndex(name, path, options || { unique: false });\n            });\n            \n            return store;\n          } catch (error) {\n            console.error(`Erro ao criar store ${storeName}:`, error);\n            throw error;\n          }\n        };\n        \n        // Settings store\n        createStore(STORES.SETTINGS);\n        \n        // Calls store\n        createStore(STORES.CALLS, 'id', [\n          { name: 'timestamp', path: 'timestamp' },\n          { name: 'phoneNumber', path: 'phoneNumber' },\n          { name: 'status', path: 'status' }\n        ]);\n        \n        // Reputation store\n        createStore(STORES.REPUTATION, 'phoneNumber', [\n          { name: 'category', path: 'category' },\n          { name: 'score', path: 'score' }\n        ]);\n        \n        // Community data store\n        createStore(STORES.COMMUNITY_DATA, 'phoneHash', [\n          { name: 'updatedAt', path: 'updatedAt' },\n          { name: 'expiresAt', path: 'expiresAt' }\n        ]);\n        \n        // Sync queue store\n        createStore(STORES.SYNC_QUEUE, 'id', [\n          { name: 'synced', path: 'synced' },\n          { name: 'timestamp', path: 'timestamp' },\n          { name: 'store', path: 'store' }\n        ]);\n        \n        // Profiles store\n        createStore(STORES.PROFILES, 'id', [\n          { name: 'status', path: 'status' },\n          { name: 'type', path: 'type' }\n        ]);\n        \n        // Rules store\n        createStore(STORES.RULES, 'id', [\n          { name: 'status', path: 'status' },\n          { name: 'type', path: 'type' }\n        ]);\n        \n        // Test store (para testes do sistema)\n        createStore(STORES.TEST, 'id');\n        \n        // Statistics store\n        createStore(STORES.STATISTICS, 'id');\n        \n        // Sync store\n        createStore(STORES.SYNC, 'id');\n        \n        console.log('Atualização da estrutura do banco de dados concluída.');\n      };\n    });\n  },\n  \n  /**\n   * Converte um IndexedDB request em uma Promise\n   * @param {IDBRequest} request - Requisição IndexedDB\n   * @returns {Promise<any>} Resultado da requisição\n   * @private\n   */\n  _promisifyRequest(request) {\n    return new Promise((resolve, reject) => {\n      request.onsuccess = (event) => resolve(event.target.result);\n      request.onerror = (event) => reject(event.target.error);\n    });\n  },\n  \n  /**\n   * Configura armazenamento de fallback usando localStorage\n   * @private\n   */\n  _setupFallbackStorage() {\n    console.warn('Usando fallback para localStorage');\n    \n    // Implementa interface compatível\n    this.fallbackStorage = {\n      getItem(key) {\n        try {\n          const value = localStorage.getItem(key);\n          return value ? JSON.parse(value) : null;\n        } catch (e) {\n          console.error('Erro ao ler do localStorage:', e);\n          return null;\n        }\n      },\n      \n      setItem(key, value) {\n        try {\n          localStorage.setItem(key, JSON.stringify(value));\n        } catch (e) {\n          console.error('Erro ao escrever no localStorage:', e);\n        }\n      },\n      \n      removeItem(key) {\n        try {\n          localStorage.removeItem(key);\n        } catch (e) {\n          console.error('Erro ao remover do localStorage:', e);\n        }\n      },\n      \n      getAllItems(storeName) {\n        try {\n          const items = [];\n          const prefix = `${storeName}:`;\n          \n          for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key.startsWith(prefix)) {\n              items.push(this.getItem(key));\n            }\n          }\n          \n          return items;\n        } catch (e) {\n          console.error('Erro ao ler todos os itens do localStorage:', e);\n          return [];\n        }\n      },\n      \n      clearStore(storeName) {\n        try {\n          const prefix = `${storeName}:`;\n          const keysToRemove = [];\n          \n          for (let i = 0; i < localStorage.length; i++) {\n            const key = localStorage.key(i);\n            if (key.startsWith(prefix)) {\n              keysToRemove.push(key);\n            }\n          }\n          \n          keysToRemove.forEach(key => localStorage.removeItem(key));\n        } catch (e) {\n          console.error('Erro ao limpar store no localStorage:', e);\n        }\n      }\n    };\n  }\n};\n\nexport { STORES };\nexport default offlineStorage;\n\n// Métodos diretos para compatibilidade com outros módulos\nofflineStorage.getItemDirect = async function(key) {\n  try {\n    // Extrair storeName do key se o formato for 'store:key'\n    let storeName = STORES.SETTINGS; // Padrão para keys simples\n    let storeKey = key;\n    \n    if (key.includes(':')) {\n      const parts = key.split(':');\n      storeName = parts[0];\n      storeKey = parts.slice(1).join(':');\n    }\n    \n    // Obter o item usando o método existente\n    return await this.getItem(storeName, storeKey);\n  } catch (error) {\n    console.error(`Erro ao obter item ${key} diretamente:`, error);\n    return null;\n  }\n};\n\n// Salvamos a implementação original antes de sobrescrever\nofflineStorage._originalGetItem = offlineStorage.getItem;\n\n// Sobrescrever com implementação compatível\nofflineStorage.getItem = function(storeNameOrKey, key) {\n  // Se apenas um parâmetro for fornecido, usar método direto\n  if (key === undefined) {\n    return this.getItemDirect(storeNameOrKey);\n  }\n  // Caso contrário, usar método original\n  return this._originalGetItem(storeNameOrKey, key);\n};\n\nofflineStorage.setItemDirect = async function(key, value) {\n  try {\n    // Extrair storeName do key se o formato for 'store:key'\n    let storeName = STORES.SETTINGS; // Padrão para keys simples\n    let storeKey = key;\n    \n    if (key.includes(':')) {\n      const parts = key.split(':');\n      storeName = parts[0];\n      storeKey = parts.slice(1).join(':');\n    }\n    \n    // Armazenar o item usando o método existente\n    await this.setItem(storeName, storeKey, value);\n    return true;\n  } catch (error) {\n    console.error(`Erro ao armazenar item ${key} diretamente:`, error);\n    // Se falhar, tentar armazenar no fallback\n    if (this.fallbackStorage) {\n      this.fallbackStorage.setItem(key, value);\n      return true;\n    }\n    return false;\n  }\n};\n\n// Salvamos a implementação original antes de sobrescrever\nofflineStorage._originalSetItem = offlineStorage.setItem;\n\n// Sobrescrever com implementação compatível\nofflineStorage.setItem = function(storeNameOrKey, keyOrValue, value) {\n  // Se apenas dois parâmetros forem fornecidos, usar método direto\n  if (value === undefined) {\n    return this.setItemDirect(storeNameOrKey, keyOrValue);\n  }\n  // Caso contrário, usar método original\n  return this._originalSetItem(storeNameOrKey, keyOrValue, value);\n};\n\n// Faz a mesma coisa para removeItem\nofflineStorage.removeItemDirect = async function(key) {\n  try {\n    let storeName = STORES.SETTINGS;\n    let storeKey = key;\n    \n    if (key.includes(':')) {\n      const parts = key.split(':');\n      storeName = parts[0];\n      storeKey = parts.slice(1).join(':');\n    }\n    \n    // Usar a função original diretamente para evitar recursividade\n    const transaction = this.db.transaction(storeName, 'readwrite');\n    const store = transaction.objectStore(storeName);\n    await this._promisifyRequest(store.delete(storeKey));\n    \n    // Remover do cache\n    const cacheKey = `${storeName}:${storeKey}`;\n    memoryCache.delete(cacheKey);\n    \n    return true;\n  } catch (error) {\n    console.error(`Erro ao remover item ${key} diretamente:`, error);\n    // Se falhar, tentar remover do fallback\n    if (this.fallbackStorage) {\n      this.fallbackStorage.removeItem(key);\n      return true;\n    }\n    return false;\n  }\n};\n\n// Salvamos a implementação original antes de sobrescrever\nofflineStorage._originalRemoveItem = offlineStorage.removeItem;\n\n// Sobrescrever com implementação compatível\nofflineStorage.removeItem = function(storeNameOrKey, key) {\n  // Se apenas um parâmetro for fornecido, usar método direto\n  if (key === undefined) {\n    return this.removeItemDirect(storeNameOrKey);\n  }\n  // Caso contrário, usar método original\n  return this._originalRemoveItem(storeNameOrKey, key);\n};\n"],"names":["DB_NAME","STORES","SETTINGS","CALLS","REPUTATION","COMMUNITY_DATA","SYNC_QUEUE","PROFILES","RULES","TEST","STATISTICS","SYNC","deleteDatabase","Promise","resolve","reject","console","log","deleteRequest","indexedDB","onsuccess","onerror","error","warn","onblocked","memoryCache","Map","offlineStorage","_initialized","_isDBReady","initialize","this","localStorage","getItem","setItem","db","_openDatabase","_verifyAllStoresExist","_recreateDatabase","_loadCriticalDataToCache","Array","from","objectStoreNames","join","_setupFallbackStorage","missingStores","filter","store","contains","length","close","removeItem","storeName","key","cacheKey","concat","has","get","transaction","objectStore","result","_promisifyRequest","undefined","set","fallbackStorage","value","JSON","stringify","hasKeyPath","keyPath","request","keyName","valueWithKey","_objectSpread","data","put","oncomplete","e","target","_isSyncableStore","_addToSyncQueue","delete","getAllItems","getAll","clearCache","prefix","keys","startsWith","clear","clearStore","operation","arguments","syncItem","id","Date","now","timestamp","toISOString","attempts","synced","add","getSyncQueue","limit","index","markAsSynced","ids","isArray","promises","map","async","item","syncedAt","all","includes","settings","activeProfiles","_getActiveProfiles","profile","activeRules","_getActiveRules","rule","window","Error","open","event","version","onupgradeneeded","createStore","indexes","createObjectStore","forEach","_ref","name","path","options","createIndex","unique","parse","items","i","push","keysToRemove","getItemDirect","storeKey","parts","split","slice","_originalGetItem","storeNameOrKey","setItemDirect","_originalSetItem","keyOrValue","removeItemDirect","_originalRemoveItem"],"sourceRoot":""}