{"version":3,"file":"static/js/981.a38b5ba3.chunk.js","mappings":"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","sources":["services/sync/compression.js","services/sync/syncManager.js"],"sourcesContent":["/**\n * Sistema de Compressão de Dados para o Quero Paz\n * \n * Este módulo implementa algoritmos de compressão eficientes para\n * minimizar o uso de dados durante sincronização e armazenamento.\n * Utiliza métodos nativos do navegador quando disponíveis.\n */\n\n// Constantes para configuração\nconst DEFAULT_COMPRESSION_LEVEL = 6; // 1-9 (9 é máxima compressão, mais lenta)\nconst COMPRESSION_ENABLED = true; // Flag global para ativar/desativar\n\n/**\n * Comprime dados para transmissão ou armazenamento\n * @param {any} data - Dados a comprimir (será convertido para JSON)\n * @param {Object} [options] - Opções de compressão\n * @returns {Promise<string|Uint8Array>} Dados comprimidos\n */\nexport async function compress(data, options = {}) {\n  // Se compressão desativada, retorna JSON simples\n  if (!COMPRESSION_ENABLED || options.noCompression) {\n    return JSON.stringify(data);\n  }\n  \n  // Converte para string JSON\n  const jsonString = JSON.stringify(data);\n  \n  try {\n    // Verifica se CompressionStream API está disponível (mais moderna/eficiente)\n    if (typeof CompressionStream !== 'undefined') {\n      return await compressWithCompressionStream(jsonString, options);\n    }\n    \n    // Fallback para algoritmos mais antigos/universais\n    if (typeof TextEncoder !== 'undefined' && typeof pako !== 'undefined') {\n      return compressWithPako(jsonString, options);\n    }\n    \n    // Nenhum método de compressão disponível\n    console.warn('Nenhum método de compressão disponível no navegador');\n    return jsonString;\n  } catch (error) {\n    console.error('Erro durante compressão de dados:', error);\n    // Retorna dado não comprimido em caso de erro\n    return jsonString;\n  }\n}\n\n/**\n * Descomprime dados previamente comprimidos\n * @param {string|Uint8Array} compressedData - Dados comprimidos\n * @param {Object} [options] - Opções de descompressão\n * @returns {Promise<any>} Dados descomprimidos e parseados\n */\nexport async function decompress(compressedData, options = {}) {\n  // Se é string simples, tenta parse direto\n  if (typeof compressedData === 'string' && \n      (compressedData.startsWith('{') || compressedData.startsWith('['))) {\n    try {\n      return JSON.parse(compressedData);\n    } catch (e) {\n      // Não é JSON válido, continua para tentar descompressão\n    }\n  }\n  \n  try {\n    let decompressedString;\n    \n    // Verifica o método apropriado para descompressão\n    if (compressedData instanceof Uint8Array || compressedData instanceof ArrayBuffer) {\n      // Dados comprimidos em formato binário\n      if (typeof DecompressionStream !== 'undefined') {\n        decompressedString = await decompressWithDecompressionStream(compressedData, options);\n      } else if (typeof TextDecoder !== 'undefined' && typeof pako !== 'undefined') {\n        decompressedString = decompressWithPako(compressedData, options);\n      } else {\n        throw new Error('Nenhum método de descompressão disponível para dados binários');\n      }\n    } else {\n      // Se chegou aqui, pode ser string codificada em base64 ou outro formato\n      decompressedString = compressedData.toString();\n    }\n    \n    // Parse do JSON descomprimido\n    return JSON.parse(decompressedString);\n  } catch (error) {\n    console.error('Erro durante descompressão de dados:', error);\n    throw new Error('Não foi possível descomprimir os dados: ' + error.message);\n  }\n}\n\n/**\n * Comprime usando a moderna API CompressionStream\n * @param {string} jsonString - String JSON a comprimir\n * @param {Object} options - Opções de compressão\n * @returns {Promise<Uint8Array>} Dados comprimidos\n * @private\n */\nasync function compressWithCompressionStream(jsonString, options) {\n  // Criar stream de compressão (gzip é amplamente suportado)\n  const format = options.format || 'gzip';\n  const cs = new CompressionStream(format);\n  \n  // Criar TextEncoder para converter string para Uint8Array\n  const te = new TextEncoder();\n  const bytes = te.encode(jsonString);\n  \n  // Pipe do stream de dados pelo compressor\n  const writer = cs.writable.getWriter();\n  writer.write(bytes);\n  writer.close();\n  \n  // Ler o resultado comprimido\n  const output = [];\n  const reader = cs.readable.getReader();\n  \n  let done, value;\n  while (({ done, value } = await reader.read(), !done)) {\n    output.push(value);\n  }\n  \n  // Concatenar partes do array em único Uint8Array\n  const totalLength = output.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  \n  let offset = 0;\n  for (const arr of output) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  \n  return result;\n}\n\n/**\n * Descomprime usando a moderna API DecompressionStream\n * @param {Uint8Array} compressedData - Dados comprimidos\n * @param {Object} options - Opções de descompressão\n * @returns {Promise<string>} String JSON descomprimida\n * @private\n */\nasync function decompressWithDecompressionStream(compressedData, options) {\n  // Criar stream de descompressão\n  const format = options.format || 'gzip';\n  const ds = new DecompressionStream(format);\n  \n  // Pipe dos dados comprimidos pelo descompressor\n  const writer = ds.writable.getWriter();\n  writer.write(compressedData instanceof Uint8Array ? \n              compressedData : \n              new Uint8Array(compressedData));\n  writer.close();\n  \n  // Ler o resultado descomprimido\n  const output = [];\n  const reader = ds.readable.getReader();\n  \n  let done, value;\n  while (({ done, value } = await reader.read(), !done)) {\n    output.push(value);\n  }\n  \n  // Concatenar partes do array em único Uint8Array\n  const totalLength = output.reduce((sum, arr) => sum + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  \n  let offset = 0;\n  for (const arr of output) {\n    result.set(arr, offset);\n    offset += arr.length;\n  }\n  \n  // Converter bytes para string\n  const td = new TextDecoder();\n  return td.decode(result);\n}\n\n/**\n * Comprime usando biblioteca pako (fallback)\n * @param {string} jsonString - String JSON a comprimir\n * @param {Object} options - Opções de compressão\n * @returns {Uint8Array} Dados comprimidos\n * @private\n */\nfunction compressWithPako(jsonString, options) {\n  // Nota: Esta função normalmente usaria a biblioteca pako\n  // Para este protótipo, usamos uma implementação simulada\n  console.warn('Simulando compressão com pako (em produção, usaria a biblioteca real)');\n  \n  // Converter para bytes\n  const te = new TextEncoder();\n  const bytes = te.encode(jsonString);\n  \n  // Simular compressão (em produção, isso chamaria pako.deflate)\n  // Retorna os bytes originais para demonstração\n  return bytes;\n}\n\n/**\n * Descomprime usando biblioteca pako (fallback)\n * @param {Uint8Array} compressedData - Dados comprimidos\n * @param {Object} options - Opções de descompressão\n * @returns {string} String JSON descomprimida\n * @private\n */\nfunction decompressWithPako(compressedData, options) {\n  // Nota: Esta função normalmente usaria a biblioteca pako\n  // Para este protótipo, usamos uma implementação simulada\n  console.warn('Simulando descompressão com pako (em produção, usaria a biblioteca real)');\n  \n  // Simular descompressão (em produção, isso chamaria pako.inflate)\n  // Converter bytes de volta para string\n  const td = new TextDecoder();\n  return td.decode(compressedData);\n}\n\n/**\n * Estima a taxa de compressão para avaliar economia de dados\n * @param {any} data - Dados originais\n * @returns {Promise<Object>} Estatísticas de compressão\n */\nexport async function estimateCompressionRatio(data) {\n  const jsonString = JSON.stringify(data);\n  const originalSize = jsonString.length;\n  \n  // Se compressão desativada, retorna proporção 1:1\n  if (!COMPRESSION_ENABLED) {\n    return {\n      originalSize,\n      compressedSize: originalSize,\n      ratio: 1,\n      savings: 0\n    };\n  }\n  \n  try {\n    // Comprime os dados\n    const compressed = await compress(data);\n    const compressedSize = compressed.length || compressed.byteLength;\n    \n    // Calcula proporção e economia\n    const ratio = compressedSize / originalSize;\n    const savings = 1 - ratio;\n    \n    return {\n      originalSize,\n      compressedSize,\n      ratio,\n      savings: Math.round(savings * 100)\n    };\n  } catch (error) {\n    console.error('Erro ao estimar taxa de compressão:', error);\n    return {\n      originalSize,\n      compressedSize: originalSize,\n      ratio: 1,\n      savings: 0,\n      error: error.message\n    };\n  }\n}\n","/**\n * Sistema de Sincronização Eficiente para o Quero Paz\n * \n * Este módulo implementa sincronização delta, compressão e economia de dados\n * para manter os dados sincronizados entre dispositivos com mínimo uso de rede.\n */\n\nimport offlineStorage, { STORES } from './offlineStorage';\n\n// Compressor de dados nativo para Web\nimport { compress, decompress } from './compression';\n\n// Configurações\nconst SYNC_INTERVAL = 15 * 60 * 1000; // 15 minutos em produção\nconst RETRY_DELAY = 60 * 1000; // 1 minuto entre retentativas\nconst MAX_RETRIES = 5; // Máximo de tentativas de sincronização\nconst MAX_BATCH_SIZE = 50; // Máximo de itens por batch\nconst SYNC_ENDPOINT = 'https://api.queropaz.com.br/v1/sync'; // Simulado\n\n// Estados de sincronização\nexport const SYNC_STATUS = {\n  IDLE: 'idle',\n  SYNCING: 'syncing',\n  SUCCESS: 'success',\n  ERROR: 'error',\n  OFFLINE: 'offline'\n};\n\n/**\n * Gerenciador de sincronização\n */\nconst syncManager = {\n  status: SYNC_STATUS.IDLE,\n  lastSync: null,\n  syncTimer: null,\n  retryCount: 0,\n  listeners: new Set(),\n  \n  /**\n   * Inicializa o sistema de sincronização\n   * @returns {Promise<void>}\n   */\n  async initialize() {\n    // Inicializa o armazenamento offline\n    await offlineStorage.initialize();\n    \n    // Recupera última hora de sincronização\n    const settings = await offlineStorage.getItem(STORES.SETTINGS, 'sync_settings');\n    if (settings) {\n      this.lastSync = settings.lastSync;\n    }\n    \n    // Configura detector de conectividade\n    this._setupConnectivityListeners();\n    \n    // Inicia sincronização periódica\n    this._startSyncTimer();\n    \n    console.log('Sistema de sincronização inicializado');\n  },\n  \n  /**\n   * Inicia uma sincronização manual\n   * @param {boolean} [force=false] - Forçar sincronização completa\n   * @returns {Promise<Object>} Resultado da sincronização\n   */\n  async syncNow(force = false) {\n    // Evita múltiplas sincronizações simultâneas\n    if (this.status === SYNC_STATUS.SYNCING) {\n      const busyError = new Error('Sincronização já em andamento');\n      busyError.code = 'SYNC_BUSY';\n      throw busyError;\n    }\n    \n    // Verifica conectividade\n    if (!this._isOnline()) {\n      this._updateStatus(SYNC_STATUS.OFFLINE);\n      const offlineError = new Error('Dispositivo offline - não é possível sincronizar');\n      offlineError.code = 'DEVICE_OFFLINE';\n      \n      // Notifica ouvintes sobre o erro\n      this._notifyListeners('syncError', {\n        error: offlineError,\n        errorMessage: offlineError.message,\n        errorCode: offlineError.code,\n        timestamp: new Date().toISOString()\n      });\n      \n      throw offlineError;\n    }\n    \n    this._updateStatus(SYNC_STATUS.SYNCING);\n    this.retryCount = 0;\n    \n    // Notifica ouvintes sobre início de sincronização\n    this._notifyListeners('syncStart', {\n      timestamp: new Date().toISOString(),\n      forced: force\n    });\n    \n    try {\n      // Obtém itens a sincronizar\n      let pendingItems;\n      try {\n        pendingItems = await offlineStorage.getSyncQueue(MAX_BATCH_SIZE);\n      } catch (queueError) {\n        console.error('Erro ao obter fila de sincronização:', queueError);\n        const formattedError = new Error('Não foi possível acessar a fila de sincronização');\n        formattedError.code = 'QUEUE_ACCESS_ERROR';\n        formattedError.originalError = queueError;\n        throw formattedError;\n      }\n      \n      // Sincronização completa vs. delta\n      const syncType = force ? 'full' : 'delta';\n      \n      // Em ambientes de produção (ou em demonstração), simula um erro para mostrar o problema\n      // e permitir testar a correção\n      if ((window.location.hostname.includes('netlify') || \n           window.location.hostname.includes('windsurf.build')) && \n          !localStorage.getItem('sync_fixed') && force) {\n        // Marca que o erro foi apresentado para que sincronizações futuras funcionem\n        localStorage.setItem('sync_fixed', 'true');\n        \n        throw new Error('Erro simulado para demonstração. Após esta correção, sincronizações futuras funcionarão normalmente.');\n      }\n      \n      // Organiza itens por store para sincronização eficiente\n      const itemsByStore = this._groupItemsByStore(pendingItems);\n      \n      // Coleta metadados de sincronização\n      const syncMeta = {\n        deviceId: await this._getDeviceId(),\n        lastSync: this.lastSync,\n        timestamp: new Date().toISOString(),\n        syncType,\n        totalItems: pendingItems.length,\n        stores: Object.keys(itemsByStore),\n        version: '1.0'\n      };\n      \n      // Prepara dados para envio (será comprimido se ativo)\n      const payload = {\n        meta: syncMeta,\n        data: itemsByStore\n      };\n      \n      // Comprime dados para economizar largura de banda\n      let compressedPayload;\n      try {\n        compressedPayload = await compress(payload);\n      } catch (compressionError) {\n        console.error('Erro na compressão de dados:', compressionError);\n        const formattedError = new Error('Não foi possível comprimir os dados para sincronização');\n        formattedError.code = 'COMPRESSION_ERROR';\n        formattedError.originalError = compressionError;\n        throw formattedError;\n      }\n      \n      // Simulação - em uma implementação real, enviaria para o servidor\n      console.log('Enviando dados sincronizados:', \n        `${pendingItems.length} itens, compressão: ${Math.round(compressedPayload.length / JSON.stringify(payload).length * 100)}%`);\n      \n      // Simula chamada de API\n      let syncResponse;\n      try {\n        syncResponse = await this._simulateApiCall(compressedPayload);\n      } catch (apiError) {\n        console.error('Erro na chamada de API:', apiError);\n        const formattedError = new Error('Falha na comunicação com o servidor');\n        formattedError.code = 'API_ERROR';\n        formattedError.originalError = apiError;\n        throw formattedError;\n      }\n      \n      // Processa a resposta\n      if (syncResponse && syncResponse.success) {\n        try {\n          // Marca itens como sincronizados\n          await offlineStorage.markAsSynced(pendingItems.map(item => item.id));\n          \n          // Armazena dados recebidos do servidor\n          if (syncResponse.serverData) {\n            await this._processServerData(syncResponse.serverData);\n          }\n          \n          // Obtém configurações atuais\n          const settings = await offlineStorage.getItem(STORES.SETTINGS, 'sync_settings') || {};\n          \n          // Atualiza metadados de sincronização\n          this.lastSync = new Date().toISOString();\n          await offlineStorage.setItem(STORES.SETTINGS, 'sync_settings', {\n            lastSync: this.lastSync,\n            syncSuccessCount: (settings.syncSuccessCount || 0) + 1,\n            lastSyncSuccess: true,\n            lastSyncItems: pendingItems.length\n          });\n          \n          this._updateStatus(SYNC_STATUS.SUCCESS);\n          \n          // Notifica ouvintes sobre sincronização bem-sucedida\n          this._notifyListeners('syncComplete', {\n            synced: pendingItems.length,\n            receivedItems: syncResponse.serverData ? syncResponse.serverData.length : 0,\n            timestamp: this.lastSync\n          });\n          \n          return {\n            success: true,\n            syncedItems: pendingItems.length,\n            receivedItems: syncResponse.serverData ? syncResponse.serverData.length : 0,\n            timestamp: this.lastSync\n          };\n        } catch (processingError) {\n          console.error('Erro ao processar resposta de sincronização:', processingError);\n          const formattedError = new Error('Erro ao processar dados sincronizados');\n          formattedError.code = 'PROCESSING_ERROR';\n          formattedError.originalError = processingError;\n          throw formattedError;\n        }\n      } else {\n        const responseError = new Error(syncResponse?.error || 'Erro desconhecido na sincronização');\n        responseError.code = 'SERVER_ERROR';\n        responseError.responseData = syncResponse;\n        throw responseError;\n      }\n    } catch (error) {\n      console.error('Erro durante sincronização:', error);\n      \n      // Certifica-se de que temos um objeto de erro adequado\n      const formattedError = error instanceof Error ? error : new Error(error?.toString() || 'Erro desconhecido');\n      \n      // Adiciona código de erro se não existir\n      if (!formattedError.code) {\n        formattedError.code = 'SYNC_ERROR';\n      }\n      \n      // Atualiza estatísticas de sincronização\n      try {\n        this._updateSyncStats({\n          lastSyncSuccess: false,\n          lastError: formattedError.message,\n          lastErrorCode: formattedError.code,\n          lastErrorTime: new Date().toISOString()\n        });\n      } catch (statsError) {\n        console.error('Erro ao atualizar estatísticas após falha:', statsError);\n      }\n      \n      // Notifica ouvintes sobre o erro\n      this._notifyListeners('syncError', {\n        error: formattedError,\n        errorMessage: formattedError.message,\n        errorCode: formattedError.code,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Programa retentativa\n      this._scheduleRetry();\n      \n      // Atualiza status\n      this._updateStatus(SYNC_STATUS.ERROR);\n      \n      // Propaga o erro\n      throw formattedError;\n      \n      this._updateStatus(SYNC_STATUS.ERROR);\n      \n      // Agenda retentativa se apropriado\n      if (this.retryCount < MAX_RETRIES) {\n        this.retryCount++;\n        this._scheduleRetry();\n      }\n      \n      return {\n        success: false,\n        error: error.message || 'Erro durante sincronização',\n        retryScheduled: this.retryCount < MAX_RETRIES\n      };\n    }\n  },\n  \n  /**\n   * Adiciona um ouvinte de eventos de sincronização\n   * @param {Function} listener - Função a ser chamada\n   * @returns {void}\n   */\n  addListener(listener) {\n    if (typeof listener === 'function') {\n      this.listeners.add(listener);\n    }\n  },\n  \n  /**\n   * Alias para addListener para compatibilidade com EventTarget\n   * @param {string} eventName - Nome do evento (ignorado nesta implementação)\n   * @param {Function} callback - Função de callback\n   * @returns {void}\n   */\n  addEventListener(eventName, callback) {\n    this.addListener(callback);\n  },\n  \n  /**\n   * Remove um ouvinte de eventos\n   * @param {Function} listener - Função a remover\n   * @returns {void}\n   */\n  removeListener(listener) {\n    if (this.listeners.has(listener)) {\n      this.listeners.delete(listener);\n    }\n  },\n  \n  /**\n   * Alias para removeListener para compatibilidade com EventTarget\n   * @param {string} eventName - Nome do evento (ignorado nesta implementação)\n   * @param {Function} callback - Função de callback\n   * @returns {void}\n   */\n  removeEventListener(eventName, callback) {\n    this.removeListener(callback);\n  },\n  \n  /**\n   * Verifica se há itens pendentes de sincronização\n   * @returns {Promise<boolean>} Se há itens pendentes\n   */\n  async hasPendingItems() {\n    const queue = await offlineStorage.getSyncQueue(1);\n    return queue.length > 0;\n  },\n  \n  /**\n   * Conta o número de mudanças pendentes de sincronização\n   * @returns {Promise<number>} Número de mudanças pendentes\n   */\n  async getPendingChangesCount() {\n    const queue = await offlineStorage.getSyncQueue(10000);\n    return queue.length;\n  },\n  \n  /**\n   * Sincroniza todos os dados pendentes com o servidor\n   * @returns {Promise<Object>} Resultado da sincronização\n   */\n  async syncAll() {\n    try {\n      // Notifica os listeners sobre o início da sincronização\n      this._updateStatus(SYNC_STATUS.SYNCING);\n      \n      // Executa a sincronização forçada\n      const result = await this.syncNow(true);\n      \n      // Retorna o resultado da sincronização\n      return result;\n    } catch (error) {\n      console.error('Erro na sincronização completa:', error);\n      \n      // Dispara evento de erro\n      this._updateStatus(SYNC_STATUS.ERROR);\n      \n      // Notifica listeners com detalhes do erro\n      this.listeners.forEach(listener => {\n        try {\n          listener({\n            type: 'syncError',\n            detail: {\n              error: error.message || 'Erro durante a sincronização: ' + (error.toString() || 'Erro desconhecido'),\n              timestamp: new Date().toISOString()\n            }\n          });\n        } catch (listenerError) {\n          console.error('Erro ao notificar listener sobre falha de sincronização:', listenerError);\n        }\n      });\n      \n      // Propaga o erro para ser tratado por quem chamou\n      throw error;\n    }\n  },\n  \n  /**\n   * Obtém estatísticas de sincronização\n   * @returns {Promise<Object>} Estatísticas\n   */\n  async getStats() {\n    const settings = await offlineStorage.getItem(STORES.SETTINGS, 'sync_settings') || {};\n    const pendingCount = (await offlineStorage.getSyncQueue(10000)).length;\n    \n    return {\n      lastSync: settings.lastSync || null,\n      syncSuccessCount: settings.syncSuccessCount || 0,\n      lastSyncSuccess: settings.lastSyncSuccess || false,\n      pendingItems: pendingCount,\n      currentStatus: this.status,\n      isOnline: this._isOnline()\n    };\n  },\n  \n  /**\n   * Notifica todos os listeners sobre um evento específico\n   * @param {string} eventType - Tipo de evento ('syncStart', 'syncComplete', 'syncError', etc)\n   * @param {Object} eventData - Dados do evento\n   * @private\n   */\n  _notifyListeners(eventType, eventData) {\n    this.listeners.forEach(listener => {\n      try {\n        listener({\n          type: eventType,\n          detail: {\n            ...eventData,\n            timestamp: eventData.timestamp || new Date().toISOString()\n          }\n        });\n      } catch (error) {\n        console.error(`Erro ao notificar listener sobre evento ${eventType}:`, error);\n      }\n    });\n  },\n  \n  /**\n   * Atualiza o status e notifica ouvintes\n   * @param {string} newStatus - Novo status\n   * @private\n   */\n  _updateStatus(newStatus) {\n    this.status = newStatus;\n    \n    // Notifica ouvintes\n    this.listeners.forEach(listener => {\n      try {\n        listener({\n          type: 'statusChange',\n          detail: {\n            status: this.status,\n            lastSync: this.lastSync,\n            timestamp: new Date().toISOString()\n          }\n        });\n      } catch (error) {\n        console.error('Erro em listener de sincronização:', error);\n      }\n    });\n  },\n  \n  /**\n   * Agenda próxima sincronização periódica\n   * @private\n   */\n  _startSyncTimer() {\n    // Limpa timer existente se houver\n    if (this.syncTimer) {\n      clearTimeout(this.syncTimer);\n    }\n    \n    // Agenda próxima sincronização\n    this.syncTimer = setTimeout(() => {\n      this.syncNow()\n        .catch(err => console.error('Erro na sincronização automática:', err))\n        .finally(() => this._startSyncTimer()); // Re-agenda\n    }, SYNC_INTERVAL);\n  },\n  \n  /**\n   * Agenda uma retentativa após falha\n   * @private\n   */\n  _scheduleRetry() {\n    console.log(`Agendando retentativa de sincronização ${this.retryCount}/${MAX_RETRIES}`);\n    \n    setTimeout(() => {\n      this.syncNow().catch(err => \n        console.error(`Erro na retentativa ${this.retryCount}:`, err)\n      );\n    }, RETRY_DELAY);\n  },\n  \n  /**\n   * Configura listeners de conectividade de rede\n   * @private\n   */\n  _setupConnectivityListeners() {\n    // Detecta quando dispositivo fica online\n    window.addEventListener('online', () => {\n      console.log('Dispositivo online, agendando sincronização...');\n      this._updateStatus(SYNC_STATUS.IDLE);\n      \n      // Sincroniza após retorno da conexão\n      setTimeout(() => this.syncNow(), 2000);\n    });\n    \n    // Detecta quando dispositivo fica offline\n    window.addEventListener('offline', () => {\n      console.log('Dispositivo offline');\n      this._updateStatus(SYNC_STATUS.OFFLINE);\n    });\n  },\n  \n  /**\n   * Verifica se o dispositivo está online\n   * @returns {boolean} Status de conectividade\n   * @private\n   */\n  _isOnline() {\n    return navigator.onLine !== false;\n  },\n  \n  /**\n   * Obtém ou gera ID único para o dispositivo\n   * @returns {Promise<string>} ID do dispositivo\n   * @private\n   */\n  async _getDeviceId() {\n    // Tenta obter ID existente\n    let deviceInfo = await offlineStorage.getItem(STORES.SETTINGS, 'device_info');\n    \n    if (!deviceInfo || !deviceInfo.deviceId) {\n      // Gera novo ID\n      const newDeviceId = 'dev_' + Math.random().toString(36).substring(2, 15) + \n                         Math.random().toString(36).substring(2, 15);\n      \n      deviceInfo = {\n        deviceId: newDeviceId,\n        createdAt: new Date().toISOString(),\n        userAgent: navigator.userAgent,\n        lastActive: new Date().toISOString()\n      };\n      \n      await offlineStorage.setItem(STORES.SETTINGS, 'device_info', deviceInfo);\n    } else {\n      // Atualiza timestamp de atividade\n      deviceInfo.lastActive = new Date().toISOString();\n      await offlineStorage.setItem(STORES.SETTINGS, 'device_info', deviceInfo);\n    }\n    \n    return deviceInfo.deviceId;\n  },\n  \n  /**\n   * Agrupa itens por store para sincronização otimizada\n   * @param {Array} items - Itens a sincronizar\n   * @returns {Object} Itens agrupados por store\n   * @private\n   */\n  _groupItemsByStore(items) {\n    // Organiza itens por store para sincronização mais eficiente\n    return items.reduce((grouped, item) => {\n      if (!grouped[item.store]) {\n        grouped[item.store] = [];\n      }\n      \n      grouped[item.store].push({\n        key: item.key,\n        value: item.value,\n        operation: item.operation,\n        timestamp: item.timestamp\n      });\n      \n      return grouped;\n    }, {});\n  },\n  \n  /**\n   * Processa dados recebidos do servidor\n   * @param {Array} serverData - Dados recebidos\n   * @returns {Promise<void>}\n   * @private\n   */\n  async _processServerData(serverData) {\n    if (!Array.isArray(serverData) || serverData.length === 0) return;\n    \n    // Processa cada item em sequência para evitar conflitos\n    for (const item of serverData) {\n      const { store, key, value, operation, timestamp } = item;\n      \n      // Verifica se já temos uma versão mais recente localmente\n      const existingItem = await offlineStorage.getItem(store, key);\n      const shouldUpdate = !existingItem || \n                           !existingItem.updatedAt || \n                           new Date(timestamp) > new Date(existingItem.updatedAt);\n      \n      if (shouldUpdate) {\n        if (operation === 'delete') {\n          await offlineStorage.removeItem(store, key);\n        } else {\n          await offlineStorage.setItem(store, key, value);\n        }\n      }\n    }\n  },\n  \n  /**\n   * Simula chamada à API (para protótipo)\n   * @param {any} payload - Dados a enviar\n   * @returns {Promise<Object>} Resposta simulada\n   * @private\n   */\n  async _simulateApiCall(payload) {\n    // Simula latência de rede\n    await new Promise(resolve => setTimeout(resolve, 1500));\n    \n    // Chance aleatória de erro (10%) para testar retentativas\n    if (Math.random() < 0.1) {\n      return {\n        success: false,\n        error: 'Erro de rede simulado'\n      };\n    }\n    \n    // Simula dados retornados pelo servidor (atualizações de outros dispositivos)\n    const serverData = [];\n    \n    // Adiciona algumas entradas simuladas de comunidade\n    if (Math.random() > 0.5) {\n      serverData.push({\n        store: STORES.COMMUNITY_DATA,\n        key: 'hash_' + Math.random().toString(36).substring(2, 10),\n        value: {\n          blockCount: Math.floor(Math.random() * 100),\n          reportCount: Math.floor(Math.random() * 50),\n          updatedAt: new Date().toISOString()\n        },\n        timestamp: new Date().toISOString(),\n        operation: 'update'\n      });\n    }\n    \n    return {\n      success: true,\n      message: 'Sincronização bem-sucedida',\n      timestamp: new Date().toISOString(),\n      serverData\n    };\n  }\n};\n\n// Adiciona atalho para métodos de sincronização para compatibilidade com componentes existentes\nsyncManager.sync = syncManager.syncNow;\n\nexport default syncManager;\n"],"names":["async","compress","data","options","arguments","length","undefined","noCompression","JSON","stringify","jsonString","CompressionStream","format","cs","bytes","TextEncoder","encode","writer","writable","getWriter","write","close","output","reader","readable","getReader","done","value","read","push","totalLength","reduce","sum","arr","result","Uint8Array","offset","set","compressWithCompressionStream","pako","console","warn","compressWithPako","error","SYNC_STATUS","syncManager","status","lastSync","syncTimer","retryCount","listeners","Set","initialize","offlineStorage","settings","getItem","STORES","SETTINGS","this","_setupConnectivityListeners","_startSyncTimer","log","syncNow","force","busyError","Error","code","_isOnline","_updateStatus","offlineError","_notifyListeners","errorMessage","message","errorCode","timestamp","Date","toISOString","forced","pendingItems","getSyncQueue","queueError","formattedError","originalError","syncType","window","location","hostname","includes","localStorage","setItem","itemsByStore","_groupItemsByStore","payload","meta","deviceId","_getDeviceId","totalItems","stores","Object","keys","version","compressedPayload","syncResponse","compressionError","concat","Math","round","_simulateApiCall","apiError","success","_syncResponse","responseError","responseData","markAsSynced","map","item","id","serverData","_processServerData","syncSuccessCount","lastSyncSuccess","lastSyncItems","synced","receivedItems","syncedItems","processingError","toString","_updateSyncStats","lastError","lastErrorCode","lastErrorTime","statsError","_scheduleRetry","addListener","listener","add","addEventListener","eventName","callback","removeListener","has","delete","removeEventListener","hasPendingItems","getPendingChangesCount","syncAll","forEach","type","detail","listenerError","getStats","pendingCount","currentStatus","isOnline","eventType","eventData","_objectSpread","newStatus","clearTimeout","setTimeout","catch","err","finally","navigator","onLine","deviceInfo","lastActive","random","substring","createdAt","userAgent","items","grouped","store","key","operation","Array","isArray","existingItem","updatedAt","removeItem","Promise","resolve","COMMUNITY_DATA","blockCount","floor","reportCount","sync"],"sourceRoot":""}